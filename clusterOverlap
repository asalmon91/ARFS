function [ ol ] = clusterOverlap( images, data )
%clusterOverlap allows clusters to steal frames from other clusters
%   This proceeds in order of highest average ncc value
%   A frame is stolen if it is predicted to overlap by >= 95% area
%   This step is important as it prevents over clustering, which would lead
%   to inconsistencies in frame choice due to the randomness of kmeans.

% OverLap Data (oldata)
ol = data;
[hh,ww] = size(images{1});
thr = 0.95; % ARB, set by user?
a = (-ww*thr)+ww; % horz radius of elipse
b = (-hh*thr)+hh; % vert radius of elipse
% t=0:pi/50:2*pi;
nFrames = numel(ol.frames);
% Number of Clusters (nc)
nc = numel(ol.clusters.sizes);
ol.clusters.names = (1:nc)';
ol.clusters.centroids = zeros(nc,2);
stolen = zeros(nFrames,nc);
destroyed = zeros(nc,1);

% Determine order with which to proceed (highest ave score to lowest)
clScore = zeros(nc,1);
for i=1:nc
    clScore(i) = mean(ol.scores.prelim(ol.clusters.assign==i));
end

[~,order] = sort(clScore, 'descend');
% Steal frames
for i=1:nc
    % Current Cluster (cc)
    cc = find(ol.clusters.assign==order(i));
    if numel(cc) == 0;
        destroyed(i) = i;
        fprintf('\nCluster # %i destroyed!\n',i);
        continue;
    end
    ol.clusters.centroids(order(i),1)=mean(ol.x(ol.clusters.assign==order(i)));
    ol.clusters.centroids(order(i),2)=mean(ol.y(ol.clusters.assign==order(i)));
    if i == nc
        break;
    end
    for j=1:nFrames
        if order(i) == ol.clusters.assign(j) || ismember(j,stolen)
            continue;
        end
        % dist between centroid(i) and frame(j)
        x1 = ol.x(j) - ol.clusters.centroids(order(i),1);
        y1 = ol.y(j) - ol.clusters.centroids(order(i),2);
        ang = atan(y1/x1);
        d1 = abs(y1/sin(ang));
        % dist between centroid(i) and tolerance boundary (elliptical)
        x2 = a*cos(ang);
        y2 = b*sin(ang);
        d2 = sqrt((x2^2)+(y2^2));
        if d1 <= d2
            ol.clusters.assign(j) = order(i);
            stolen(j,i) = j;
        end
    end
%     figure();
%     scatter(oldata.x,oldata.y,[],oldata.cluster)
%     t = 0:pi/50:2*pi;
%     patch((a*cos(t))+oldata.centroids(order(i),1),(b*sin(t))+oldata.centroids(order(i),2),...
%         [1,1,1],'facecolor','none')
end
destroyed(destroyed == 0) = [];
if ~isempty(destroyed)
    ol.clusters.names(ol.clusters.names==destroyed) = [];
    ol.clusters.sizes(destroyed) = [];
end

end



